{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useRef } from \"react\"; // export function useTimerOldVersion(callback, delay) {\n//     const savedCallback = useRef();\n//     // Remember the latest callback.\n//     useEffect(() => {\n//         savedCallback.current = callback;\n//     }, [callback]);\n//     // Set up the interval.\n//     useEffect(() => {\n//         function tick() {\n//             savedCallback.current();\n//         }\n//         if (delay !== null) {\n//             let id = setInterval(tick, delay);\n//             return () => clearInterval(id);\n//         }\n//     }, [delay]);\n// }\n\nexport default function useTimer(callback, delay) {\n  _s();\n\n  const savedCallback = useRef(); // Remember the latest callback.\n\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]); // Set up the interval.\n\n  useEffect(() => {\n    function tick(deltaMS) {\n      savedCallback.current(deltaMS);\n    }\n\n    if (delay !== null) {\n      let id = absoluteSetInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}\n\n_s(useTimer, \"dqNZMqbncP+HtqBlD20aSNv0Ugk=\");\n\nconst absoluteSetInterval = (handler, delay) => {\n  let baseTime = Date.now();\n\n  const callHandler = () => {\n    let timePassedSinceLastCall = Date.now() - baseTime;\n\n    if (timePassedSinceLastCall > 1000) {\n      baseTime = Date.now(); // must be set before calling handler to avoid time delay in executing it\n\n      handler(timePassedSinceLastCall);\n    }\n  };\n\n  return setInterval(callHandler, delay);\n};","map":{"version":3,"sources":["C:/fokus2/mini_project_main/src/hooks/useTimer.js"],"names":["useEffect","useRef","useTimer","callback","delay","savedCallback","current","tick","deltaMS","id","absoluteSetInterval","clearInterval","handler","baseTime","Date","now","callHandler","timePassedSinceLastCall","setInterval"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,OAAlC,C,CAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAASC,QAAT,CAAkBC,QAAlB,EAA4BC,KAA5B,EAAmC;AAAA;;AAC9C,QAAMC,aAAa,GAAGJ,MAAM,EAA5B,CAD8C,CAG9C;;AACAD,EAAAA,SAAS,CAAC,MAAM;AACZK,IAAAA,aAAa,CAACC,OAAd,GAAwBH,QAAxB;AACH,GAFQ,EAEN,CAACA,QAAD,CAFM,CAAT,CAJ8C,CAQ9C;;AACAH,EAAAA,SAAS,CAAC,MAAM;AACZ,aAASO,IAAT,CAAcC,OAAd,EAAuB;AACnBH,MAAAA,aAAa,CAACC,OAAd,CAAsBE,OAAtB;AACH;;AACD,QAAIJ,KAAK,KAAK,IAAd,EAAoB;AAChB,UAAIK,EAAE,GAAGC,mBAAmB,CAACH,IAAD,EAAOH,KAAP,CAA5B;AACA,aAAO,MAAMO,aAAa,CAACF,EAAD,CAA1B;AACH;AACJ,GARQ,EAQN,CAACL,KAAD,CARM,CAAT;AASH;;GAlBuBF,Q;;AAoBxB,MAAMQ,mBAAmB,GAAG,CAACE,OAAD,EAAUR,KAAV,KAAoB;AAC5C,MAAIS,QAAQ,GAAGC,IAAI,CAACC,GAAL,EAAf;;AACA,QAAMC,WAAW,GAAG,MAAM;AACtB,QAAIC,uBAAuB,GAAGH,IAAI,CAACC,GAAL,KAAaF,QAA3C;;AACA,QAAII,uBAAuB,GAAG,IAA9B,EAAoC;AAChCJ,MAAAA,QAAQ,GAAGC,IAAI,CAACC,GAAL,EAAX,CADgC,CACT;;AACvBH,MAAAA,OAAO,CAACK,uBAAD,CAAP;AACH;AACJ,GAND;;AAOA,SAAOC,WAAW,CAACF,WAAD,EAAcZ,KAAd,CAAlB;AACH,CAVD","sourcesContent":["import { useEffect, useRef } from \"react\";\n\n// export function useTimerOldVersion(callback, delay) {\n//     const savedCallback = useRef();\n\n//     // Remember the latest callback.\n//     useEffect(() => {\n//         savedCallback.current = callback;\n//     }, [callback]);\n\n//     // Set up the interval.\n//     useEffect(() => {\n//         function tick() {\n//             savedCallback.current();\n//         }\n//         if (delay !== null) {\n//             let id = setInterval(tick, delay);\n//             return () => clearInterval(id);\n//         }\n//     }, [delay]);\n// }\n\nexport default function useTimer(callback, delay) {\n    const savedCallback = useRef();\n\n    // Remember the latest callback.\n    useEffect(() => {\n        savedCallback.current = callback;\n    }, [callback]);\n\n    // Set up the interval.\n    useEffect(() => {\n        function tick(deltaMS) {\n            savedCallback.current(deltaMS);\n        }\n        if (delay !== null) {\n            let id = absoluteSetInterval(tick, delay);\n            return () => clearInterval(id);\n        }\n    }, [delay]);\n}\n\nconst absoluteSetInterval = (handler, delay) => {\n    let baseTime = Date.now();\n    const callHandler = () => {\n        let timePassedSinceLastCall = Date.now() - baseTime;\n        if (timePassedSinceLastCall > 1000) {\n            baseTime = Date.now(); // must be set before calling handler to avoid time delay in executing it\n            handler(timePassedSinceLastCall);\n        }\n    };\n    return setInterval(callHandler, delay);\n};\n"]},"metadata":{},"sourceType":"module"}