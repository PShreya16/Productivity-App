{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"C:\\\\fokus2\\\\mini_project_main\\\\src\\\\containers\\\\taskBoard\\\\TaskBoard.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { updateOrder } from \"./taskBoardSlice\";\nimport TaskCard from \"./../../components/TaskBoard/TaskCard\";\nimport { DragDropContext, Draggable, Droppable } from \"react-beautiful-dnd\";\nimport { Flipper } from \"react-flip-toolkit\";\nimport { focusOnTask } from \"./taskBoardSlice\";\nimport styled from \"styled-components\";\nimport TaskInput from \"./../../components/TaskBoard/TaskInput\";\nimport Divider from \"./../../components/TaskBoard/Divider\";\nimport NoTasks from \"../../components/TaskBoard/NoTasks\";\nconst TaskBoardContainer = styled.div`\n    flex: 1 1 0;\n    display: flex;\n    min-width: 396px;\n    flex-direction: column;\n    align-items: center;\n    overflow-y: scroll; // to enable scrolling by default for this flex-container only\n`;\n_c = TaskBoardContainer;\nconst EmptySpace = styled.div`\n    display: flex;\n    min-width: 10px;\n    min-height: 10px;\n    margin: 10px;\n`;\n_c2 = EmptySpace;\nexport function TaskBoard() {\n  _s();\n\n  const tasks = useSelector(state => state.tasks.taskArray);\n  const meta = useSelector(state => state.tasks.meta);\n  let focussedTask = meta.focussedTaskIndex !== -1 ? tasks[meta.focussedTaskIndex] : null;\n  const dispatch = useDispatch();\n\n  function handleOnDragEnd(result) {\n    if (!result.destination) return;\n    let items = [...tasks.map(i => ({ ...i\n    }))];\n    const [reorderedItem] = items.splice(result.source.index, 1);\n    items.splice(result.destination.index, 0, reorderedItem);\n    let i = result.source.index;\n    let direction = result.destination.index > result.source.index; // direction true means moving right & swapping\n    // below is logic to reset globalKeys to maintain correct sort order.\n    // below is logic to reset globalKeys to maintain correct sort order.\n    // below is logic to reset globalKeys to maintain correct sort order.\n\n    while (i != result.destination.index) {\n      if (direction) {\n        items[i].globalKey = tasks[i].globalKey;\n        i++;\n      } else {\n        items[i].globalKey = tasks[i].globalKey;\n        i--;\n      }\n\n      if (i == result.destination.index) {\n        items[i].globalKey = tasks[i].globalKey;\n      }\n    }\n\n    if (meta.focussedTaskIndex !== -1) {\n      let greaterIndex = Math.max(result.destination.index, result.source.index);\n      let smallerIndex = Math.min(result.destination.index, result.source.index);\n\n      if (result.source.index === meta.focussedTaskIndex) {\n        dispatch(focusOnTask(result.destination.index));\n      } else if (meta.focussedTaskIndex >= smallerIndex && meta.focussedTaskIndex <= greaterIndex) {\n        if (result.destination.index > result.source.index) {\n          dispatch(focusOnTask(meta.focussedTaskIndex - 1)); // -1\n        } else {\n          dispatch(focusOnTask(meta.focussedTaskIndex + 1)); // +1\n        }\n      }\n    }\n\n    dispatch(updateOrder(items)); // order is imp. focus then updateOrder\n  }\n\n  function getFlipKey() {\n    let flipKey = \"\";\n    tasks.forEach(i => {\n      flipKey += `${i.globalKey}`;\n    });\n    flipKey += `${meta.completedTaskStartIndex}`;\n    return flipKey;\n  }\n\n  function isFocussed(id) {\n    if (focussedTask !== null && focussedTask.id === id) return true;\n    return false;\n  } // input has both onChange and onKeyDown - can be optimised by using one and combining\n\n\n  return /*#__PURE__*/_jsxDEV(TaskBoardContainer, {\n    children: [/*#__PURE__*/_jsxDEV(TaskInput, {\n      focussedTaskIndex: meta.focussedTaskIndex\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 97,\n      columnNumber: 13\n    }, this), tasks.length === 0 ? /*#__PURE__*/_jsxDEV(NoTasks, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 98,\n      columnNumber: 35\n    }, this) : tasks.length === meta.completedTasksCount && /*#__PURE__*/_jsxDEV(NoTasks, {\n      allCompleted: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 98,\n      columnNumber: 94\n    }, this), /*#__PURE__*/_jsxDEV(Flipper, {\n      flipKey: getFlipKey(),\n      children: [/*#__PURE__*/_jsxDEV(DragDropContext, {\n        onDragEnd: handleOnDragEnd,\n        children: /*#__PURE__*/_jsxDEV(Droppable, {\n          droppableId: \"dropArea\",\n          children: provided => /*#__PURE__*/_jsxDEV(\"div\", { ...provided.droppableProps,\n            ref: provided.innerRef,\n            children: [tasks.map((i, index) => !i.isCompleted ? /*#__PURE__*/_jsxDEV(Draggable, {\n              isDragDisabled: i.isCompleted,\n              draggableId: `${i.id}`,\n              index: index,\n              children: provided2 => /*#__PURE__*/_jsxDEV(TaskCard, {\n                focussedTaskIndex: meta.focussedTaskIndex,\n                focussedTaskGlobalKey: meta.focussedTaskIndex !== -1 ? tasks[meta.focussedTaskIndex].globalKey : -1,\n                taskIndex: index,\n                forwardRBDProvided: provided2,\n                task: i,\n                isFocussed: isFocussed(i.id)\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 108,\n                columnNumber: 49\n              }, this)\n            }, i.id, false, {\n              fileName: _jsxFileName,\n              lineNumber: 106,\n              columnNumber: 41\n            }, this) : \"\"), provided.placeholder]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 103,\n            columnNumber: 29\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 101,\n          columnNumber: 21\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 100,\n        columnNumber: 17\n      }, this), meta.completedTaskStartIndex !== -1 && /*#__PURE__*/_jsxDEV(Divider, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 128,\n        columnNumber: 57\n      }, this), meta.showCompletedTasks && tasks.map((i, index) => i.isCompleted ? /*#__PURE__*/_jsxDEV(TaskCard, {\n        focussedTaskIndex: meta.focussedTaskIndex,\n        focussedTaskGlobalKey: meta.focussedTaskIndex !== -1 ? tasks[meta.focussedTaskIndex].globalKey : -1,\n        taskIndex: index,\n        forwardRBDProvided: {\n          innerRef: null\n        },\n        task: i,\n        isFocussed: isFocussed(i.id)\n      }, i.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 133,\n        columnNumber: 29\n      }, this) : \"\")]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 99,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(EmptySpace, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 147,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 96,\n    columnNumber: 9\n  }, this);\n}\n\n_s(TaskBoard, \"Jq9p5X2L3bbNXudEsTiLE8kW0f0=\", false, function () {\n  return [useSelector, useSelector, useDispatch];\n});\n\n_c3 = TaskBoard;\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"TaskBoardContainer\");\n$RefreshReg$(_c2, \"EmptySpace\");\n$RefreshReg$(_c3, \"TaskBoard\");","map":{"version":3,"sources":["C:/fokus2/mini_project_main/src/containers/taskBoard/TaskBoard.js"],"names":["React","useState","useSelector","useDispatch","updateOrder","TaskCard","DragDropContext","Draggable","Droppable","Flipper","focusOnTask","styled","TaskInput","Divider","NoTasks","TaskBoardContainer","div","EmptySpace","TaskBoard","tasks","state","taskArray","meta","focussedTask","focussedTaskIndex","dispatch","handleOnDragEnd","result","destination","items","map","i","reorderedItem","splice","source","index","direction","globalKey","greaterIndex","Math","max","smallerIndex","min","getFlipKey","flipKey","forEach","completedTaskStartIndex","isFocussed","id","length","completedTasksCount","provided","droppableProps","innerRef","isCompleted","provided2","placeholder","showCompletedTasks"],"mappings":";;;;;AAAA,OAAOA,KAAP,IAAgBC,QAAhB,QAAgC,OAAhC;AACA,SAASC,WAAT,EAAsBC,WAAtB,QAAyC,aAAzC;AACA,SAASC,WAAT,QAA4B,kBAA5B;AACA,OAAOC,QAAP,MAAqB,uCAArB;AACA,SAASC,eAAT,EAA0BC,SAA1B,EAAqCC,SAArC,QAAsD,qBAAtD;AACA,SAASC,OAAT,QAAwB,oBAAxB;AACA,SAASC,WAAT,QAA4B,kBAA5B;AACA,OAAOC,MAAP,MAAmB,mBAAnB;AACA,OAAOC,SAAP,MAAsB,wCAAtB;AACA,OAAOC,OAAP,MAAoB,sCAApB;AACA,OAAOC,OAAP,MAAoB,oCAApB;AAEA,MAAMC,kBAAkB,GAAGJ,MAAM,CAACK,GAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,CAPA;KAAMD,kB;AASN,MAAME,UAAU,GAAGN,MAAM,CAACK,GAAI;AAC9B;AACA;AACA;AACA;AACA,CALA;MAAMC,U;AAON,OAAO,SAASC,SAAT,GAAqB;AAAA;;AACxB,QAAMC,KAAK,GAAGjB,WAAW,CAAEkB,KAAD,IAAWA,KAAK,CAACD,KAAN,CAAYE,SAAxB,CAAzB;AACA,QAAMC,IAAI,GAAGpB,WAAW,CAAEkB,KAAD,IAAWA,KAAK,CAACD,KAAN,CAAYG,IAAxB,CAAxB;AACA,MAAIC,YAAY,GAAGD,IAAI,CAACE,iBAAL,KAA2B,CAAC,CAA5B,GAAgCL,KAAK,CAACG,IAAI,CAACE,iBAAN,CAArC,GAAgE,IAAnF;AACA,QAAMC,QAAQ,GAAGtB,WAAW,EAA5B;;AAEA,WAASuB,eAAT,CAAyBC,MAAzB,EAAiC;AAC7B,QAAI,CAACA,MAAM,CAACC,WAAZ,EAAyB;AAEzB,QAAIC,KAAK,GAAG,CAAC,GAAGV,KAAK,CAACW,GAAN,CAAWC,CAAD,KAAQ,EAAE,GAAGA;AAAL,KAAR,CAAV,CAAJ,CAAZ;AACA,UAAM,CAACC,aAAD,IAAkBH,KAAK,CAACI,MAAN,CAAaN,MAAM,CAACO,MAAP,CAAcC,KAA3B,EAAkC,CAAlC,CAAxB;AACAN,IAAAA,KAAK,CAACI,MAAN,CAAaN,MAAM,CAACC,WAAP,CAAmBO,KAAhC,EAAuC,CAAvC,EAA0CH,aAA1C;AAEA,QAAID,CAAC,GAAGJ,MAAM,CAACO,MAAP,CAAcC,KAAtB;AACA,QAAIC,SAAS,GAAGT,MAAM,CAACC,WAAP,CAAmBO,KAAnB,GAA2BR,MAAM,CAACO,MAAP,CAAcC,KAAzD,CAR6B,CAQmC;AAChE;AACA;AACA;;AACA,WAAOJ,CAAC,IAAIJ,MAAM,CAACC,WAAP,CAAmBO,KAA/B,EAAsC;AAClC,UAAIC,SAAJ,EAAe;AACXP,QAAAA,KAAK,CAACE,CAAD,CAAL,CAASM,SAAT,GAAqBlB,KAAK,CAACY,CAAD,CAAL,CAASM,SAA9B;AACAN,QAAAA,CAAC;AACJ,OAHD,MAGO;AACHF,QAAAA,KAAK,CAACE,CAAD,CAAL,CAASM,SAAT,GAAqBlB,KAAK,CAACY,CAAD,CAAL,CAASM,SAA9B;AACAN,QAAAA,CAAC;AACJ;;AAED,UAAIA,CAAC,IAAIJ,MAAM,CAACC,WAAP,CAAmBO,KAA5B,EAAmC;AAC/BN,QAAAA,KAAK,CAACE,CAAD,CAAL,CAASM,SAAT,GAAqBlB,KAAK,CAACY,CAAD,CAAL,CAASM,SAA9B;AACH;AACJ;;AAED,QAAIf,IAAI,CAACE,iBAAL,KAA2B,CAAC,CAAhC,EAAmC;AAC/B,UAAIc,YAAY,GAAGC,IAAI,CAACC,GAAL,CAASb,MAAM,CAACC,WAAP,CAAmBO,KAA5B,EAAmCR,MAAM,CAACO,MAAP,CAAcC,KAAjD,CAAnB;AACA,UAAIM,YAAY,GAAGF,IAAI,CAACG,GAAL,CAASf,MAAM,CAACC,WAAP,CAAmBO,KAA5B,EAAmCR,MAAM,CAACO,MAAP,CAAcC,KAAjD,CAAnB;;AAEA,UAAIR,MAAM,CAACO,MAAP,CAAcC,KAAd,KAAwBb,IAAI,CAACE,iBAAjC,EAAoD;AAChDC,QAAAA,QAAQ,CAACf,WAAW,CAACiB,MAAM,CAACC,WAAP,CAAmBO,KAApB,CAAZ,CAAR;AACH,OAFD,MAEO,IAAIb,IAAI,CAACE,iBAAL,IAA0BiB,YAA1B,IAA0CnB,IAAI,CAACE,iBAAL,IAA0Bc,YAAxE,EAAsF;AACzF,YAAIX,MAAM,CAACC,WAAP,CAAmBO,KAAnB,GAA2BR,MAAM,CAACO,MAAP,CAAcC,KAA7C,EAAoD;AAChDV,UAAAA,QAAQ,CAACf,WAAW,CAACY,IAAI,CAACE,iBAAL,GAAyB,CAA1B,CAAZ,CAAR,CADgD,CACG;AACtD,SAFD,MAEO;AACHC,UAAAA,QAAQ,CAACf,WAAW,CAACY,IAAI,CAACE,iBAAL,GAAyB,CAA1B,CAAZ,CAAR,CADG,CACgD;AACtD;AACJ;AACJ;;AAEDC,IAAAA,QAAQ,CAACrB,WAAW,CAACyB,KAAD,CAAZ,CAAR,CAzC6B,CAyCC;AACjC;;AAED,WAASc,UAAT,GAAsB;AAClB,QAAIC,OAAO,GAAG,EAAd;AACAzB,IAAAA,KAAK,CAAC0B,OAAN,CAAed,CAAD,IAAO;AACjBa,MAAAA,OAAO,IAAK,GAAEb,CAAC,CAACM,SAAU,EAA1B;AACH,KAFD;AAGAO,IAAAA,OAAO,IAAK,GAAEtB,IAAI,CAACwB,uBAAwB,EAA3C;AACA,WAAOF,OAAP;AACH;;AAED,WAASG,UAAT,CAAoBC,EAApB,EAAwB;AACpB,QAAIzB,YAAY,KAAK,IAAjB,IAAyBA,YAAY,CAACyB,EAAb,KAAoBA,EAAjD,EAAqD,OAAO,IAAP;AACrD,WAAO,KAAP;AACH,GA9DuB,CAgExB;;;AAEA,sBACI,QAAC,kBAAD;AAAA,4BACI,QAAC,SAAD;AAAW,MAAA,iBAAiB,EAAE1B,IAAI,CAACE;AAAnC;AAAA;AAAA;AAAA;AAAA,YADJ,EAEKL,KAAK,CAAC8B,MAAN,KAAiB,CAAjB,gBAAqB,QAAC,OAAD;AAAA;AAAA;AAAA;AAAA,YAArB,GAAmC9B,KAAK,CAAC8B,MAAN,KAAiB3B,IAAI,CAAC4B,mBAAtB,iBAA6C,QAAC,OAAD;AAAS,MAAA,YAAY,EAAE;AAAvB;AAAA;AAAA;AAAA;AAAA,YAFrF,eAGI,QAAC,OAAD;AAAS,MAAA,OAAO,EAAEP,UAAU,EAA5B;AAAA,8BACI,QAAC,eAAD;AAAiB,QAAA,SAAS,EAAEjB,eAA5B;AAAA,+BACI,QAAC,SAAD;AAAW,UAAA,WAAW,EAAC,UAAvB;AAAA,oBACMyB,QAAD,iBACG,oBAASA,QAAQ,CAACC,cAAlB;AAAkC,YAAA,GAAG,EAAED,QAAQ,CAACE,QAAhD;AAAA,uBACKlC,KAAK,CAACW,GAAN,CAAU,CAACC,CAAD,EAAII,KAAJ,KACP,CAACJ,CAAC,CAACuB,WAAH,gBACI,QAAC,SAAD;AAAW,cAAA,cAAc,EAAEvB,CAAC,CAACuB,WAA7B;AAAqD,cAAA,WAAW,EAAG,GAAEvB,CAAC,CAACiB,EAAG,EAA1E;AAA6E,cAAA,KAAK,EAAEb,KAApF;AAAA,wBACMoB,SAAD,iBACG,QAAC,QAAD;AACI,gBAAA,iBAAiB,EAAEjC,IAAI,CAACE,iBAD5B;AAEI,gBAAA,qBAAqB,EAAEF,IAAI,CAACE,iBAAL,KAA2B,CAAC,CAA5B,GAAgCL,KAAK,CAACG,IAAI,CAACE,iBAAN,CAAL,CAA8Ba,SAA9D,GAA0E,CAAC,CAFtG;AAGI,gBAAA,SAAS,EAAEF,KAHf;AAII,gBAAA,kBAAkB,EAAEoB,SAJxB;AAKI,gBAAA,IAAI,EAAExB,CALV;AAMI,gBAAA,UAAU,EAAEgB,UAAU,CAAChB,CAAC,CAACiB,EAAH;AAN1B;AAAA;AAAA;AAAA;AAAA;AAFR,eAA+CjB,CAAC,CAACiB,EAAjD;AAAA;AAAA;AAAA;AAAA,oBADJ,GAcI,EAfP,CADL,EAmBKG,QAAQ,CAACK,WAnBd;AAAA;AAAA;AAAA;AAAA;AAAA;AAFR;AAAA;AAAA;AAAA;AAAA;AADJ;AAAA;AAAA;AAAA;AAAA,cADJ,EA6BKlC,IAAI,CAACwB,uBAAL,KAAiC,CAAC,CAAlC,iBAAuC,QAAC,OAAD;AAAA;AAAA;AAAA;AAAA,cA7B5C,EA+BKxB,IAAI,CAACmC,kBAAL,IACGtC,KAAK,CAACW,GAAN,CAAU,CAACC,CAAD,EAAII,KAAJ,KACNJ,CAAC,CAACuB,WAAF,gBACI,QAAC,QAAD;AACI,QAAA,iBAAiB,EAAEhC,IAAI,CAACE,iBAD5B;AAEI,QAAA,qBAAqB,EAAEF,IAAI,CAACE,iBAAL,KAA2B,CAAC,CAA5B,GAAgCL,KAAK,CAACG,IAAI,CAACE,iBAAN,CAAL,CAA8Ba,SAA9D,GAA0E,CAAC,CAFtG;AAGI,QAAA,SAAS,EAAEF,KAHf;AAKI,QAAA,kBAAkB,EAAE;AAAEkB,UAAAA,QAAQ,EAAE;AAAZ,SALxB;AAMI,QAAA,IAAI,EAAEtB,CANV;AAOI,QAAA,UAAU,EAAEgB,UAAU,CAAChB,CAAC,CAACiB,EAAH;AAP1B,SAISjB,CAAC,CAACiB,EAJX;AAAA;AAAA;AAAA;AAAA,cADJ,GAWI,EAZR,CAhCR;AAAA;AAAA;AAAA;AAAA;AAAA,YAHJ,eAmDI,QAAC,UAAD;AAAA;AAAA;AAAA;AAAA,YAnDJ;AAAA;AAAA;AAAA;AAAA;AAAA,UADJ;AAuDH;;GAzHe9B,S;UACEhB,W,EACDA,W,EAEIC,W;;;MAJLe,S","sourcesContent":["import React, { useState } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { updateOrder } from \"./taskBoardSlice\";\nimport TaskCard from \"./../../components/TaskBoard/TaskCard\";\nimport { DragDropContext, Draggable, Droppable } from \"react-beautiful-dnd\";\nimport { Flipper } from \"react-flip-toolkit\";\nimport { focusOnTask } from \"./taskBoardSlice\";\nimport styled from \"styled-components\";\nimport TaskInput from \"./../../components/TaskBoard/TaskInput\";\nimport Divider from \"./../../components/TaskBoard/Divider\";\nimport NoTasks from \"../../components/TaskBoard/NoTasks\";\n\nconst TaskBoardContainer = styled.div`\n    flex: 1 1 0;\n    display: flex;\n    min-width: 396px;\n    flex-direction: column;\n    align-items: center;\n    overflow-y: scroll; // to enable scrolling by default for this flex-container only\n`;\n\nconst EmptySpace = styled.div`\n    display: flex;\n    min-width: 10px;\n    min-height: 10px;\n    margin: 10px;\n`;\n\nexport function TaskBoard() {\n    const tasks = useSelector((state) => state.tasks.taskArray);\n    const meta = useSelector((state) => state.tasks.meta);\n    let focussedTask = meta.focussedTaskIndex !== -1 ? tasks[meta.focussedTaskIndex] : null;\n    const dispatch = useDispatch();\n\n    function handleOnDragEnd(result) {\n        if (!result.destination) return;\n\n        let items = [...tasks.map((i) => ({ ...i }))];\n        const [reorderedItem] = items.splice(result.source.index, 1);\n        items.splice(result.destination.index, 0, reorderedItem);\n\n        let i = result.source.index;\n        let direction = result.destination.index > result.source.index; // direction true means moving right & swapping\n        // below is logic to reset globalKeys to maintain correct sort order.\n        // below is logic to reset globalKeys to maintain correct sort order.\n        // below is logic to reset globalKeys to maintain correct sort order.\n        while (i != result.destination.index) {\n            if (direction) {\n                items[i].globalKey = tasks[i].globalKey;\n                i++;\n            } else {\n                items[i].globalKey = tasks[i].globalKey;\n                i--;\n            }\n\n            if (i == result.destination.index) {\n                items[i].globalKey = tasks[i].globalKey;\n            }\n        }\n\n        if (meta.focussedTaskIndex !== -1) {\n            let greaterIndex = Math.max(result.destination.index, result.source.index);\n            let smallerIndex = Math.min(result.destination.index, result.source.index);\n\n            if (result.source.index === meta.focussedTaskIndex) {\n                dispatch(focusOnTask(result.destination.index));\n            } else if (meta.focussedTaskIndex >= smallerIndex && meta.focussedTaskIndex <= greaterIndex) {\n                if (result.destination.index > result.source.index) {\n                    dispatch(focusOnTask(meta.focussedTaskIndex - 1)); // -1\n                } else {\n                    dispatch(focusOnTask(meta.focussedTaskIndex + 1)); // +1\n                }\n            }\n        }\n\n        dispatch(updateOrder(items)); // order is imp. focus then updateOrder\n    }\n\n    function getFlipKey() {\n        let flipKey = \"\";\n        tasks.forEach((i) => {\n            flipKey += `${i.globalKey}`;\n        });\n        flipKey += `${meta.completedTaskStartIndex}`;\n        return flipKey;\n    }\n\n    function isFocussed(id) {\n        if (focussedTask !== null && focussedTask.id === id) return true;\n        return false;\n    }\n\n    // input has both onChange and onKeyDown - can be optimised by using one and combining\n\n    return (\n        <TaskBoardContainer>\n            <TaskInput focussedTaskIndex={meta.focussedTaskIndex} />\n            {tasks.length === 0 ? <NoTasks /> : tasks.length === meta.completedTasksCount && <NoTasks allCompleted={true} />}\n            <Flipper flipKey={getFlipKey()}>\n                <DragDropContext onDragEnd={handleOnDragEnd}>\n                    <Droppable droppableId=\"dropArea\">\n                        {(provided) => (\n                            <div {...provided.droppableProps} ref={provided.innerRef}>\n                                {tasks.map((i, index) =>\n                                    !i.isCompleted ? (\n                                        <Draggable isDragDisabled={i.isCompleted} key={i.id} draggableId={`${i.id}`} index={index}>\n                                            {(provided2) => (\n                                                <TaskCard\n                                                    focussedTaskIndex={meta.focussedTaskIndex}\n                                                    focussedTaskGlobalKey={meta.focussedTaskIndex !== -1 ? tasks[meta.focussedTaskIndex].globalKey : -1}\n                                                    taskIndex={index}\n                                                    forwardRBDProvided={provided2}\n                                                    task={i}\n                                                    isFocussed={isFocussed(i.id)}\n                                                />\n                                            )}\n                                        </Draggable>\n                                    ) : (\n                                        \"\"\n                                    )\n                                )}\n                                {provided.placeholder}\n                            </div>\n                        )}\n                    </Droppable>\n                </DragDropContext>\n\n                {meta.completedTaskStartIndex !== -1 && <Divider />}\n\n                {meta.showCompletedTasks &&\n                    tasks.map((i, index) =>\n                        i.isCompleted ? (\n                            <TaskCard\n                                focussedTaskIndex={meta.focussedTaskIndex}\n                                focussedTaskGlobalKey={meta.focussedTaskIndex !== -1 ? tasks[meta.focussedTaskIndex].globalKey : -1}\n                                taskIndex={index}\n                                key={i.id}\n                                forwardRBDProvided={{ innerRef: null }}\n                                task={i}\n                                isFocussed={isFocussed(i.id)}\n                            />\n                        ) : (\n                            \"\"\n                        )\n                    )}\n            </Flipper>\n            <EmptySpace />\n        </TaskBoardContainer>\n    );\n}\n"]},"metadata":{},"sourceType":"module"}