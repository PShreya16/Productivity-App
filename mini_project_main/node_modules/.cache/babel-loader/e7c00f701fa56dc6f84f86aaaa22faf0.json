{"ast":null,"code":"import { createSlice } from \"@reduxjs/toolkit\";\nimport { MIN_TO_MS } from \"./../../helpers/constants\";\nimport { updatePageTitle } from \"./../../helpers\";\nconst labelOptions = {\n  work: {\n    color: \"#de1738\",\n    count: 0\n  },\n  personal: {\n    color: \"#89CFF0\",\n    count: 0\n  },\n  fitness: {\n    color: \"#76ff7a\",\n    count: 0\n  },\n  metime: {\n    color: \"#7442c8\",\n    count: 0\n  },\n  explore: {\n    color: \"#efc0fe\",\n    count: 0\n  }\n};\nexport const tasksSlice = createSlice({\n  name: \"tasks\",\n  initialState: {\n    taskArray: [],\n    labels: labelOptions,\n    soundscape: {\n      track: \"mute\",\n      isPlaying: false,\n      volume: 0.7\n    },\n    meta: {\n      globalKey: 0,\n      completedTaskStartIndex: -1,\n      focussedTaskIndex: -1,\n      showCompletedTasks: true,\n      completedTasksCount: 0,\n      totalTaskListTime: 0,\n      remainingTaskListTime: 0\n    }\n  },\n  reducers: {\n    create: (tasks, {\n      payload\n    }) => {\n      payload.time = payload.time * MIN_TO_MS;\n      payload.remainingTime = payload.remainingTime * MIN_TO_MS;\n      tasks.taskArray.unshift(payload);\n      tasks.meta.totalTaskListTime += payload.time;\n      tasks.meta.remainingTaskListTime += payload.time;\n      if (tasks.meta.completedTaskStartIndex != -1) ++tasks.meta.completedTaskStartIndex;\n    },\n    remove: (tasks, {\n      payload\n    }) => {\n      tasks.taskArray = tasks.taskArray.filter(i => {\n        if (i.id !== payload) return true;else {\n          if (!i.isCompleted) {\n            if (tasks.meta.completedTaskStartIndex != -1) --tasks.meta.completedTaskStartIndex;\n          } else {\n            tasks.meta.completedTasksCount--;\n\n            if (tasks.meta.completedTaskStartIndex == tasks.taskArray.length - 1) {\n              tasks.meta.completedTaskStartIndex = -1;\n            }\n          }\n\n          if (!i.isCompleted) {\n            tasks.meta.remainingTaskListTime -= i.remainingTime;\n          }\n\n          tasks.meta.totalTaskListTime -= i.time;\n          return false;\n        }\n      });\n    },\n    updateTaskObject: (tasks, {\n      payload\n    }) => {\n      tasks.taskArray = tasks.taskArray.map(i => i.id === payload.id ? payload : i);\n    },\n    updateTaskContent: ({\n      taskArray\n    }, {\n      payload\n    }) => {\n      taskArray.forEach(i => {\n        if (i.id === payload.id) {\n          i.content = payload.updatedTaskContent;\n        }\n      });\n    },\n    updateTaskLabel: ({\n      taskArray\n    }, {\n      payload\n    }) => {\n      taskArray.forEach(i => {\n        if (i.id === payload.id) {\n          i.label = payload.label;\n        }\n      });\n    },\n    updateTaskTime: (tasks, {\n      payload\n    }) => {\n      tasks.taskArray.forEach(i => {\n        if (i.id === payload.id) {\n          tasks.meta.totalTaskListTime -= i.time;\n          tasks.meta.remainingTaskListTime -= i.remainingTime;\n          tasks.meta.totalTaskListTime += payload.updatedTime * MIN_TO_MS;\n          tasks.meta.remainingTaskListTime += payload.updatedTime * MIN_TO_MS;\n          i.remainingTime = payload.updatedTime * MIN_TO_MS;\n          i.time = payload.updatedTime * MIN_TO_MS;\n        }\n      });\n    },\n    updateTaskTimeByVal: (tasks, {\n      payload\n    }) => {\n      if (tasks.taskArray[payload.focussedTaskIndex].remainingTime + payload.val * MIN_TO_MS < 0) {\n        tasks.meta.remainingTaskListTime -= tasks.taskArray[payload.focussedTaskIndex].remainingTime;\n        tasks.taskArray[payload.focussedTaskIndex].remainingTime = 0;\n      } else {\n        tasks.meta.remainingTaskListTime -= tasks.taskArray[payload.focussedTaskIndex].remainingTime;\n        tasks.taskArray[payload.focussedTaskIndex].remainingTime += payload.val * MIN_TO_MS;\n        tasks.meta.remainingTaskListTime += tasks.taskArray[payload.focussedTaskIndex].remainingTime;\n      }\n\n      if (tasks.taskArray[payload.focussedTaskIndex].time + payload.val * MIN_TO_MS < 0) {\n        tasks.meta.totalTaskListTime -= tasks.taskArray[payload.focussedTaskIndex].time;\n        tasks.taskArray[payload.focussedTaskIndex].time = 0;\n      } else {\n        tasks.meta.totalTaskListTime -= tasks.taskArray[payload.focussedTaskIndex].time;\n        tasks.taskArray[payload.focussedTaskIndex].time += payload.val * MIN_TO_MS;\n        tasks.meta.totalTaskListTime += tasks.taskArray[payload.focussedTaskIndex].time;\n      }\n    },\n    updateOrder: (tasks, {\n      payload\n    }) => {\n      tasks.taskArray = payload;\n    },\n    focusOnTask: (tasks, {\n      payload\n    }) => {\n      if (typeof payload === \"number\") {\n        tasks.meta.focussedTaskIndex = payload;\n      } else {\n        // done tasks, remaining time = 0 tasks shouldnt be picked.\n        let completedTaskStartIndex = tasks.meta.completedTaskStartIndex !== -1 ? tasks.meta.completedTaskStartIndex : tasks.taskArray.length;\n        let index = -1;\n\n        if (payload === \"smallest\") {\n          let time,\n              lowest = Number.POSITIVE_INFINITY;\n\n          for (let i = 0; i < completedTaskStartIndex; i++) {\n            time = tasks.taskArray[i].remainingTime;\n            if (time < 1000) continue; // rem. time less than second(1000ms)\n\n            if (time < lowest) {\n              lowest = time;\n              index = i;\n            }\n          }\n        } else if (payload === \"largest\") {\n          let time,\n              highest = Number.NEGATIVE_INFINITY;\n\n          for (let i = 0; i < completedTaskStartIndex; i++) {\n            time = tasks.taskArray[i].remainingTime;\n            if (time < 1000) continue; // rem. time less than second(1000ms)\n\n            if (time > highest) {\n              highest = time;\n              index = i;\n            }\n          }\n        }\n\n        updatePageTitle(`Fokus: ${tasks.taskArray[index].content}`);\n        tasks.meta.focussedTaskIndex = index;\n      }\n    },\n    resetFocussedTask: tasks => {\n      tasks.meta.focussedTaskIndex = -1;\n    },\n    tick: (tasks, {\n      payload\n    }) => {\n      tasks.taskArray[payload.focussedTaskIndex].remainingTime -= payload.deltaMS;\n      tasks.meta.remainingTaskListTime -= payload.deltaMS;\n\n      if (tasks.taskArray[payload.focussedTaskIndex].remainingTime < 0) {\n        tasks.taskArray[payload.focussedTaskIndex].remainingTime = 0;\n      }\n\n      if (tasks.meta.remainingTaskListTime < 0) {\n        tasks.meta.remainingTaskListTime = 0;\n      }\n    },\n    resetTaskTimer: (tasks, {\n      payload\n    }) => {\n      tasks.taskArray[payload].isRunning = false;\n      tasks.meta.remainingTaskListTime -= tasks.taskArray[payload].remainingTime;\n      tasks.meta.remainingTaskListTime += tasks.taskArray[payload].time;\n      tasks.taskArray[payload].remainingTime = tasks.taskArray[payload].time;\n    },\n    toggleIsRunning: (tasks, {\n      payload\n    }) => {\n      if (payload.val !== undefined) tasks.taskArray[payload.idx].isRunning = payload.val;else tasks.taskArray[payload.idx].isRunning = !tasks.taskArray[payload.idx].isRunning;\n    },\n    toggleShowCompletedTasks: tasks => {\n      tasks.meta.showCompletedTasks = !tasks.meta.showCompletedTasks;\n    },\n    toggleIsCompleted: (tasks, {\n      payload\n    }) => {\n      tasks.taskArray.forEach(i => {\n        if (i.id === payload) {\n          if (i.isCompleted) {\n            tasks.meta.remainingTaskListTime += i.remainingTime;\n            --tasks.meta.completedTasksCount;\n          } else {\n            tasks.meta.remainingTaskListTime -= i.remainingTime;\n            ++tasks.meta.completedTasksCount;\n          }\n\n          i.isCompleted = !i.isCompleted;\n        }\n      });\n    },\n    clearCompletedTasks: tasks => {\n      if (tasks.meta.completedTaskStartIndex !== -1) {\n        for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n          if (tasks.taskArray[i].label !== null) tasks.labels[tasks.taskArray[i].label].count--;\n          tasks.meta.totalTaskListTime -= tasks.taskArray[i].time;\n        }\n\n        tasks.taskArray.length = tasks.meta.completedTaskStartIndex;\n        tasks.meta.completedTaskStartIndex = -1;\n        tasks.meta.completedTasksCount = 0;\n      }\n    },\n    updateLabelCount: (tasks, {\n      payload\n    }) => {\n      if (payload.oldLabel !== null) tasks.labels[payload.oldLabel].count--;\n      if (payload.newLabel !== null) tasks.labels[payload.newLabel].count++;\n    },\n    incrementGlobalKey: ({\n      meta\n    }) => {\n      ++meta.globalKey;\n    },\n    rearrange: (tasks, {\n      payload\n    }) => {\n      let id = payload.id;\n\n      if (payload.markedAsComplete) {\n        if (tasks.meta.completedTaskStartIndex === -1) {\n          tasks.meta.completedTaskStartIndex = tasks.taskArray.length - 1;\n          let found = false;\n\n          for (let i = 0; i < tasks.taskArray.length - 1; i++) {\n            if (found) {\n              let temp = tasks.taskArray[i];\n              tasks.taskArray[i] = tasks.taskArray[i + 1];\n              tasks.taskArray[i + 1] = temp;\n            } else if (tasks.taskArray[i].id === id) {\n              found = true;\n              let temp = tasks.taskArray[i];\n              tasks.taskArray[i] = tasks.taskArray[i + 1];\n              tasks.taskArray[i + 1] = temp;\n            }\n          }\n\n          tasks.meta.completedTaskStartIndex = tasks.taskArray.length - 1;\n        } else {\n          let task, idx;\n\n          for (let i = 0; i < tasks.taskArray.length; i++) {\n            if (tasks.taskArray[i].id === id) {\n              task = tasks.taskArray[i];\n              idx = i;\n              break;\n            }\n          }\n\n          let pos = -1;\n\n          for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n            if (tasks.taskArray[i].globalKey > task.globalKey) continue;else {\n              pos = i;\n              break;\n            }\n          }\n\n          if (pos === -1) {\n            tasks.taskArray.push(task);\n          } else {\n            tasks.taskArray.splice(pos, 0, task);\n          }\n\n          tasks.taskArray.splice(idx, 1);\n          tasks.meta.completedTaskStartIndex -= 1;\n        }\n      } else {\n        if (tasks.meta.completedTaskStartIndex == 0) {\n          let task, idx;\n\n          for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n            if (tasks.taskArray[i].id === id) {\n              task = tasks.taskArray[i];\n              idx = i;\n              break;\n            }\n          }\n\n          tasks.taskArray.splice(idx, 1);\n          tasks.taskArray.unshift(task);\n          tasks.meta.completedTaskStartIndex = 1;\n        } else {\n          let task, idx;\n\n          for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n            if (tasks.taskArray[i].id === id) {\n              task = tasks.taskArray[i];\n              idx = i;\n              break;\n            }\n          }\n\n          let start = tasks.meta.completedTaskStartIndex - 1;\n          let pos = -1;\n\n          for (let i = start; i >= 0; i--) {\n            if (tasks.taskArray[i].globalKey < task.globalKey) continue;else {\n              pos = i;\n              break;\n            }\n          }\n\n          tasks.taskArray.splice(idx, 1);\n\n          if (pos === -1) {\n            tasks.taskArray.unshift(task);\n          } else {\n            pos++;\n            tasks.taskArray.splice(pos, 0, task);\n          }\n\n          tasks.meta.completedTaskStartIndex += 1;\n        }\n\n        if (tasks.meta.completedTaskStartIndex == tasks.taskArray.length) {\n          tasks.meta.completedTaskStartIndex = -1;\n        }\n      }\n    },\n    changeSoundscapeTrack: ({\n      soundscape\n    }, {\n      payload\n    }) => {\n      soundscape.track = payload;\n    },\n    toggleSoundscapeState: ({\n      soundscape\n    }, {\n      payload\n    }) => {\n      soundscape.isPlaying = payload;\n    },\n    updateSoundscapeVolume: ({\n      soundscape\n    }, {\n      payload\n    }) => {\n      soundscape.volume = payload;\n    }\n  }\n});\nexport const {\n  create,\n  remove,\n  updateTaskObject,\n  updateTaskContent,\n  updateTaskLabel,\n  updateTaskTime,\n  updateTaskTimeByVal,\n  focusOnTask,\n  resetFocussedTask,\n  tick,\n  resetTaskTimer,\n  toggleIsRunning,\n  toggleShowCompletedTasks,\n  toggleIsCompleted,\n  clearCompletedTasks,\n  updateOrder,\n  updateLabelCount,\n  incrementGlobalKey,\n  rearrange,\n  changeSoundscapeTrack,\n  toggleSoundscapeState,\n  updateSoundscapeVolume\n} = tasksSlice.actions;\nexport default tasksSlice.reducer;","map":{"version":3,"sources":["C:/fokus2/mini_project_main/src/containers/taskBoard/taskBoardSlice.js"],"names":["createSlice","MIN_TO_MS","updatePageTitle","labelOptions","work","color","count","personal","fitness","metime","explore","tasksSlice","name","initialState","taskArray","labels","soundscape","track","isPlaying","volume","meta","globalKey","completedTaskStartIndex","focussedTaskIndex","showCompletedTasks","completedTasksCount","totalTaskListTime","remainingTaskListTime","reducers","create","tasks","payload","time","remainingTime","unshift","remove","filter","i","id","isCompleted","length","updateTaskObject","map","updateTaskContent","forEach","content","updatedTaskContent","updateTaskLabel","label","updateTaskTime","updatedTime","updateTaskTimeByVal","val","updateOrder","focusOnTask","index","lowest","Number","POSITIVE_INFINITY","highest","NEGATIVE_INFINITY","resetFocussedTask","tick","deltaMS","resetTaskTimer","isRunning","toggleIsRunning","undefined","idx","toggleShowCompletedTasks","toggleIsCompleted","clearCompletedTasks","updateLabelCount","oldLabel","newLabel","incrementGlobalKey","rearrange","markedAsComplete","found","temp","task","pos","push","splice","start","changeSoundscapeTrack","toggleSoundscapeState","updateSoundscapeVolume","actions","reducer"],"mappings":"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","sourcesContent":["import { createSlice } from \"@reduxjs/toolkit\";\nimport { MIN_TO_MS } from \"./../../helpers/constants\";\nimport { updatePageTitle } from \"./../../helpers\";\n\nconst labelOptions = {\n    work: {\n        color: \"#de1738\",\n        count: 0,\n    },\n    personal: {\n        color: \"#89CFF0\",\n        count: 0,\n    },\n    fitness: {\n        color: \"#76ff7a\",\n        count: 0,\n    },\n    metime: {\n        color: \"#7442c8\",\n        count: 0,\n    },\n    explore: {\n        color: \"#efc0fe\",\n        count: 0,\n    },\n};\n\nexport const tasksSlice = createSlice({\n    name: \"tasks\",\n    initialState: {\n        taskArray: [],\n        labels: labelOptions,\n        soundscape: {\n            track: \"mute\",\n            isPlaying: false,\n            volume: 0.7,\n        },\n        meta: {\n            globalKey: 0,\n            completedTaskStartIndex: -1,\n            focussedTaskIndex: -1,\n            showCompletedTasks: true,\n            completedTasksCount: 0,\n            totalTaskListTime: 0,\n            remainingTaskListTime: 0,\n        },\n    },\n    reducers: {\n        create: (tasks, { payload }) => {\n            payload.time = payload.time * MIN_TO_MS;\n            payload.remainingTime = payload.remainingTime * MIN_TO_MS;\n            tasks.taskArray.unshift(payload);\n            tasks.meta.totalTaskListTime += payload.time;\n            tasks.meta.remainingTaskListTime += payload.time;\n            if (tasks.meta.completedTaskStartIndex != -1) ++tasks.meta.completedTaskStartIndex;\n        },\n        remove: (tasks, { payload }) => {\n            tasks.taskArray = tasks.taskArray.filter((i) => {\n                if (i.id !== payload) return true;\n                else {\n                    if (!i.isCompleted) {\n                        if (tasks.meta.completedTaskStartIndex != -1) --tasks.meta.completedTaskStartIndex;\n                    } else {\n                        tasks.meta.completedTasksCount--;\n                        if (tasks.meta.completedTaskStartIndex == tasks.taskArray.length - 1) {\n                            tasks.meta.completedTaskStartIndex = -1;\n                        }\n                    }\n\n                    if (!i.isCompleted) {\n                        tasks.meta.remainingTaskListTime -= i.remainingTime;\n                    }\n                    tasks.meta.totalTaskListTime -= i.time;\n\n                    return false;\n                }\n            });\n        },\n        updateTaskObject: (tasks, { payload }) => {\n            tasks.taskArray = tasks.taskArray.map((i) => (i.id === payload.id ? payload : i));\n        },\n        updateTaskContent: ({ taskArray }, { payload }) => {\n            taskArray.forEach((i) => {\n                if (i.id === payload.id) {\n                    i.content = payload.updatedTaskContent;\n                }\n            });\n        },\n        updateTaskLabel: ({ taskArray }, { payload }) => {\n            taskArray.forEach((i) => {\n                if (i.id === payload.id) {\n                    i.label = payload.label;\n                }\n            });\n        },\n        updateTaskTime: (tasks, { payload }) => {\n            tasks.taskArray.forEach((i) => {\n                if (i.id === payload.id) {\n                    tasks.meta.totalTaskListTime -= i.time;\n                    tasks.meta.remainingTaskListTime -= i.remainingTime;\n                    tasks.meta.totalTaskListTime += payload.updatedTime * MIN_TO_MS;\n                    tasks.meta.remainingTaskListTime += payload.updatedTime * MIN_TO_MS;\n                    i.remainingTime = payload.updatedTime * MIN_TO_MS;\n                    i.time = payload.updatedTime * MIN_TO_MS;\n                }\n            });\n        },\n        updateTaskTimeByVal: (tasks, { payload }) => {\n            if (tasks.taskArray[payload.focussedTaskIndex].remainingTime + payload.val * MIN_TO_MS < 0) {\n                tasks.meta.remainingTaskListTime -= tasks.taskArray[payload.focussedTaskIndex].remainingTime;\n                tasks.taskArray[payload.focussedTaskIndex].remainingTime = 0;\n            } else {\n                tasks.meta.remainingTaskListTime -= tasks.taskArray[payload.focussedTaskIndex].remainingTime;\n                tasks.taskArray[payload.focussedTaskIndex].remainingTime += payload.val * MIN_TO_MS;\n                tasks.meta.remainingTaskListTime += tasks.taskArray[payload.focussedTaskIndex].remainingTime;\n            }\n\n            if (tasks.taskArray[payload.focussedTaskIndex].time + payload.val * MIN_TO_MS < 0) {\n                tasks.meta.totalTaskListTime -= tasks.taskArray[payload.focussedTaskIndex].time;\n                tasks.taskArray[payload.focussedTaskIndex].time = 0;\n            } else {\n                tasks.meta.totalTaskListTime -= tasks.taskArray[payload.focussedTaskIndex].time;\n                tasks.taskArray[payload.focussedTaskIndex].time += payload.val * MIN_TO_MS;\n                tasks.meta.totalTaskListTime += tasks.taskArray[payload.focussedTaskIndex].time;\n            }\n        },\n        updateOrder: (tasks, { payload }) => {\n            tasks.taskArray = payload;\n        },\n        focusOnTask: (tasks, { payload }) => {\n            if (typeof payload === \"number\") {\n                tasks.meta.focussedTaskIndex = payload;\n            } else {\n                // done tasks, remaining time = 0 tasks shouldnt be picked.\n                let completedTaskStartIndex = tasks.meta.completedTaskStartIndex !== -1 ? tasks.meta.completedTaskStartIndex : tasks.taskArray.length;\n                let index = -1;\n                if (payload === \"smallest\") {\n                    let time,\n                        lowest = Number.POSITIVE_INFINITY;\n                    for (let i = 0; i < completedTaskStartIndex; i++) {\n                        time = tasks.taskArray[i].remainingTime;\n                        if (time < 1000) continue; // rem. time less than second(1000ms)\n                        if (time < lowest) {\n                            lowest = time;\n                            index = i;\n                        }\n                    }\n                } else if (payload === \"largest\") {\n                    let time,\n                        highest = Number.NEGATIVE_INFINITY;\n                    for (let i = 0; i < completedTaskStartIndex; i++) {\n                        time = tasks.taskArray[i].remainingTime;\n                        if (time < 1000) continue; // rem. time less than second(1000ms)\n                        if (time > highest) {\n                            highest = time;\n                            index = i;\n                        }\n                    }\n                }\n                updatePageTitle(`Fokus: ${tasks.taskArray[index].content}`);\n                tasks.meta.focussedTaskIndex = index;\n            }\n        },\n        resetFocussedTask: (tasks) => {\n            tasks.meta.focussedTaskIndex = -1;\n        },\n        tick: (tasks, { payload }) => {\n            tasks.taskArray[payload.focussedTaskIndex].remainingTime -= payload.deltaMS;\n            tasks.meta.remainingTaskListTime -= payload.deltaMS;\n\n            if (tasks.taskArray[payload.focussedTaskIndex].remainingTime < 0) {\n                tasks.taskArray[payload.focussedTaskIndex].remainingTime = 0;\n            }\n            if (tasks.meta.remainingTaskListTime < 0) {\n                tasks.meta.remainingTaskListTime = 0;\n            }\n        },\n        resetTaskTimer: (tasks, { payload }) => {\n            tasks.taskArray[payload].isRunning = false;\n\n            tasks.meta.remainingTaskListTime -= tasks.taskArray[payload].remainingTime;\n            tasks.meta.remainingTaskListTime += tasks.taskArray[payload].time;\n\n            tasks.taskArray[payload].remainingTime = tasks.taskArray[payload].time;\n        },\n        toggleIsRunning: (tasks, { payload }) => {\n            if (payload.val !== undefined) tasks.taskArray[payload.idx].isRunning = payload.val;\n            else tasks.taskArray[payload.idx].isRunning = !tasks.taskArray[payload.idx].isRunning;\n        },\n        toggleShowCompletedTasks: (tasks) => {\n            tasks.meta.showCompletedTasks = !tasks.meta.showCompletedTasks;\n        },\n        toggleIsCompleted: (tasks, { payload }) => {\n            tasks.taskArray.forEach((i) => {\n                if (i.id === payload) {\n                    if (i.isCompleted) {\n                        tasks.meta.remainingTaskListTime += i.remainingTime;\n                        --tasks.meta.completedTasksCount;\n                    } else {\n                        tasks.meta.remainingTaskListTime -= i.remainingTime;\n                        ++tasks.meta.completedTasksCount;\n                    }\n\n                    i.isCompleted = !i.isCompleted;\n                }\n            });\n        },\n        clearCompletedTasks: (tasks) => {\n            if (tasks.meta.completedTaskStartIndex !== -1) {\n                for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                    if (tasks.taskArray[i].label !== null) tasks.labels[tasks.taskArray[i].label].count--;\n\n                    tasks.meta.totalTaskListTime -= tasks.taskArray[i].time;\n                }\n\n                tasks.taskArray.length = tasks.meta.completedTaskStartIndex;\n                tasks.meta.completedTaskStartIndex = -1;\n                tasks.meta.completedTasksCount = 0;\n            }\n        },\n        updateLabelCount: (tasks, { payload }) => {\n            if (payload.oldLabel !== null) tasks.labels[payload.oldLabel].count--;\n            if (payload.newLabel !== null) tasks.labels[payload.newLabel].count++;\n        },\n        incrementGlobalKey: ({ meta }) => {\n            ++meta.globalKey;\n        },\n        rearrange: (tasks, { payload }) => {\n            let id = payload.id;\n\n            if (payload.markedAsComplete) {\n                if (tasks.meta.completedTaskStartIndex === -1) {\n                    tasks.meta.completedTaskStartIndex = tasks.taskArray.length - 1;\n                    let found = false;\n                    for (let i = 0; i < tasks.taskArray.length - 1; i++) {\n                        if (found) {\n                            let temp = tasks.taskArray[i];\n                            tasks.taskArray[i] = tasks.taskArray[i + 1];\n                            tasks.taskArray[i + 1] = temp;\n                        } else if (tasks.taskArray[i].id === id) {\n                            found = true;\n                            let temp = tasks.taskArray[i];\n                            tasks.taskArray[i] = tasks.taskArray[i + 1];\n                            tasks.taskArray[i + 1] = temp;\n                        }\n                    }\n                    tasks.meta.completedTaskStartIndex = tasks.taskArray.length - 1;\n                } else {\n                    let task, idx;\n                    for (let i = 0; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n                    let pos = -1;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].globalKey > task.globalKey) continue;\n                        else {\n                            pos = i;\n                            break;\n                        }\n                    }\n\n                    if (pos === -1) {\n                        tasks.taskArray.push(task);\n                    } else {\n                        tasks.taskArray.splice(pos, 0, task);\n                    }\n                    tasks.taskArray.splice(idx, 1);\n                    tasks.meta.completedTaskStartIndex -= 1;\n                }\n            } else {\n                if (tasks.meta.completedTaskStartIndex == 0) {\n                    let task, idx;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n\n                    tasks.taskArray.splice(idx, 1);\n                    tasks.taskArray.unshift(task);\n                    tasks.meta.completedTaskStartIndex = 1;\n                } else {\n                    let task, idx;\n                    for (let i = tasks.meta.completedTaskStartIndex; i < tasks.taskArray.length; i++) {\n                        if (tasks.taskArray[i].id === id) {\n                            task = tasks.taskArray[i];\n                            idx = i;\n                            break;\n                        }\n                    }\n\n                    let start = tasks.meta.completedTaskStartIndex - 1;\n                    let pos = -1;\n                    for (let i = start; i >= 0; i--) {\n                        if (tasks.taskArray[i].globalKey < task.globalKey) continue;\n                        else {\n                            pos = i;\n                            break;\n                        }\n                    }\n\n                    tasks.taskArray.splice(idx, 1);\n                    if (pos === -1) {\n                        tasks.taskArray.unshift(task);\n                    } else {\n                        pos++;\n                        tasks.taskArray.splice(pos, 0, task);\n                    }\n                    tasks.meta.completedTaskStartIndex += 1;\n                }\n\n                if (tasks.meta.completedTaskStartIndex == tasks.taskArray.length) {\n                    tasks.meta.completedTaskStartIndex = -1;\n                }\n            }\n        },\n        changeSoundscapeTrack: ({ soundscape }, { payload }) => {\n            soundscape.track = payload;\n        },\n        toggleSoundscapeState: ({ soundscape }, { payload }) => {\n            soundscape.isPlaying = payload;\n        },\n        updateSoundscapeVolume: ({ soundscape }, { payload }) => {\n            soundscape.volume = payload;\n        },\n    },\n});\n\nexport const {\n    create,\n    remove,\n    updateTaskObject,\n    updateTaskContent,\n    updateTaskLabel,\n    updateTaskTime,\n    updateTaskTimeByVal,\n    focusOnTask,\n    resetFocussedTask,\n    tick,\n    resetTaskTimer,\n    toggleIsRunning,\n    toggleShowCompletedTasks,\n    toggleIsCompleted,\n    clearCompletedTasks,\n    updateOrder,\n    updateLabelCount,\n    incrementGlobalKey,\n    rearrange,\n    changeSoundscapeTrack,\n    toggleSoundscapeState,\n    updateSoundscapeVolume,\n} = tasksSlice.actions;\n\nexport default tasksSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}